#include "../ECL_ZeroEater.h"
#include "../ECL_ZeroDevourer.h"
#include "../ECL_NanoLZ.h"
#include "ntest/ntest.h"

#include <vector>

struct ECLDatasetRecord {
    const char* ptr;
    int length;
};

typedef std::vector<ECLDatasetRecord> DatasetRecords;
static DatasetRecords& GetDatasetRecords() {
    static DatasetRecords recs;
    return recs;
}

#define ECL_TEST_APPEND_DATASET(the_string) \
    GetDatasetRecords().push_back({the_string, sizeof(the_string) - 1}); \

struct ECLTestDatasetsInitializer {
    ECLTestDatasetsInitializer() {
        // common datasets (basically for Zero-oriented algorithms)
        ECL_TEST_APPEND_DATASET("\x0");
        ECL_TEST_APPEND_DATASET("\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1");
        ECL_TEST_APPEND_DATASET("\x0\x0");
        ECL_TEST_APPEND_DATASET("\x0\x0\x0");
        ECL_TEST_APPEND_DATASET("\x0\x0\x0\x0");
        ECL_TEST_APPEND_DATASET("\x0\x0\x0\x0\x0");
        ECL_TEST_APPEND_DATASET("\x0\x1\x0\x0\x0");
        ECL_TEST_APPEND_DATASET("\x0\x0\x1\x0\x0");
        ECL_TEST_APPEND_DATASET("\x0\x1\x1\x0\x0");
        ECL_TEST_APPEND_DATASET("\x0\x1\x1\x0\x1");
        ECL_TEST_APPEND_DATASET("\x0\x1\x1\x0\x1\x0\x0\x0\x0\x0\x0");
        ECL_TEST_APPEND_DATASET("\x0\x1\x1\x0\x1\x0");
        ECL_TEST_APPEND_DATASET("\x0\x1\x1\x0\x1\x0\x1");
        ECL_TEST_APPEND_DATASET("\x0\x1\x1\x0\x1\x0\x0\x1");
        ECL_TEST_APPEND_DATASET("\x0\x1\x1\x0\x1\x0\x0\x0\x1");
        ECL_TEST_APPEND_DATASET("\x0\x1\x1\x0\x1\x0\x0\x0\x0\x1");
        ECL_TEST_APPEND_DATASET("\x0\x1\x1\x0\x1\x0\x0\x0\x0\x0\x1");
        ECL_TEST_APPEND_DATASET("\x0\x1\x1\x0\x1\x0\x0\x0\x0\x0\x0\x1");
        ECL_TEST_APPEND_DATASET("\x0\x1\x1\x0\x1\x0\x0\x0\x0\x0\x0\x0\x1");
        ECL_TEST_APPEND_DATASET("\x0\x1\x1\x0\x1\x0\x0\x0\x0\x0\x0\x0\x0\x1");
        ECL_TEST_APPEND_DATASET("\x0\x1\x1\x0\x1\x0\x0\x0\x0\x0\x0\x0\x0\x0\x1");
        ECL_TEST_APPEND_DATASET("\x0\x1\x1\x0\x1\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x1");
        ECL_TEST_APPEND_DATASET("\x0\x1\x1\x0\x1\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x1");
        ECL_TEST_APPEND_DATASET("\x0\x1\x1\x0\x1\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x1");
        ECL_TEST_APPEND_DATASET("\x0\x1\x1\x0\x1\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x1\x0");
        ECL_TEST_APPEND_DATASET("\x0\x0\x0\x0\x0\x1\x1\x0\x1\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x1\x0");
        ECL_TEST_APPEND_DATASET("\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x1\x1\x0\x1\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x1\x0");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1\x0");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1\x0\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1\x0\x0\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x0");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x0\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x0\x0\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x0\x0\x1\x0");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x0\x0\x1\x0\x1");
        // LZ datasets
        ECL_TEST_APPEND_DATASET("\x1\x2\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x2\x3\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x2\x3\x4\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x2\x3\x4\x5\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x2\x3\x4\x5\x6\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x2\x3\x4\x5\x6\x7\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x2\x3\x4\x5\x6\x7\x8\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x2\x3\x4\x5\x6\x7\x8\x9\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x2\x3\x4\x5\x6\x7\x8\x9\xA\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x2\x3\x4\x5\x6\x7\x8\x9\xA\xB\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x2\x3\x4\x5\x6\x7\x8\x9\xA\xB\xC\x1\x1\x1\x1");
        // similar 1
        ECL_TEST_APPEND_DATASET("\x1\x1\x2\x3\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x2\x3\x4\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x2\x3\x4\x5\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x2\x3\x4\x5\x6\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x2\x3\x4\x5\x6\x7\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x2\x3\x4\x5\x6\x7\x8\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x2\x3\x4\x5\x6\x7\x8\x9\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x2\x3\x4\x5\x6\x7\x8\x9\xA\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x2\x3\x4\x5\x6\x7\x8\x9\xA\xB\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x2\x3\x4\x5\x6\x7\x8\x9\xA\xB\xC\x1\x1\x1\x1");
        // similar 2
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x2\x3\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x2\x3\x4\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x2\x3\x4\x5\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x2\x3\x4\x5\x6\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x2\x3\x4\x5\x6\x7\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x2\x3\x4\x5\x6\x7\x8\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x2\x3\x4\x5\x6\x7\x8\x9\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x2\x3\x4\x5\x6\x7\x8\x9\xA\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x2\x3\x4\x5\x6\x7\x8\x9\xA\xB\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x2\x3\x4\x5\x6\x7\x8\x9\xA\xB\xC\x1\x1\x1\x1");
        // similar 3
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1\x2\x3\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1\x2\x3\x4\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1\x2\x3\x4\x5\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1\x2\x3\x4\x5\x6\x1\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1\x2\x3\x4\x5\x6\x7\x1\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1\x2\x3\x4\x5\x6\x7\x8\x1\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1\x2\x3\x4\x5\x6\x7\x8\x9\x1\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1\x2\x3\x4\x5\x6\x7\x8\x9\xA\x1\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1\x2\x3\x4\x5\x6\x7\x8\x9\xA\xB\x1\x1\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x1\x1\x1\x2\x3\x4\x5\x6\x7\x8\x9\xA\xB\xC\x1\x1\x1\x1");
        //
        ECL_TEST_APPEND_DATASET("\x1\x2\x3\x4\x5\x6\x7\x8\x9\xA\xB\xC\x1\x4\x5\x6\x7\x1\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x2\x3\x4\x5\x6\x7\x8\x9\xA\xB\xC\x1\x1\x4\x5\x6\x7\x1\x1");
        ECL_TEST_APPEND_DATASET("\x1\x2\x3\x4\x5\x6\x7\x8\x9\xA\xB\xC\x1\x1\x1\x4\x5\x6\x7\x1");
        ECL_TEST_APPEND_DATASET("\x1\x2\x3\x4\x5\x6\x7\x8\x9\xA\xB\xC\x1\x1\x1\x1\x4\x5\x6\x7");
    }
};
ECLTestDatasetsInitializer ECLTestDatasetsInitializer_instance;

#undef ECL_TEST_APPEND_DATASET

NTEST(test_ZeroEater_datasets) {
    std::vector<uint8_t> tmp;
    std::vector<uint8_t> tmp_output;
    for(auto& rec : GetDatasetRecords()) {
        auto src_data = (const uint8_t*)rec.ptr;
        auto src_size = rec.length;
        approve(src_data);
        approve(src_size);

        auto enough_size = ECL_ZERO_EATER_GET_BOUND(src_size);
        tmp.resize(enough_size);
        auto comp_size = ECL_ZeroEater_Compress(src_data, src_size, tmp.data(), enough_size);
        approve(comp_size == ECL_ZeroEater_Compress(src_data, src_size, nullptr, 0));

        tmp_output.resize(src_size);
        auto decomp_size = ECL_ZeroEater_Decompress(tmp.data(), comp_size, tmp_output.data(), src_size);
        approve(decomp_size == src_size);
        approve(0 == memcmp(src_data, tmp_output.data(), src_size));
    }
}

NTEST(test_ZeroDevourer_datasets) {
    std::vector<uint8_t> tmp;
    std::vector<uint8_t> tmp_output;
    for(auto& rec : GetDatasetRecords()) {
        auto src_data = (const uint8_t*)rec.ptr;
        auto src_size = rec.length;
        approve(src_data);
        approve(src_size);

        auto enough_size = ECL_ZERO_DEVOURER_GET_BOUND(src_size);
        tmp.resize(enough_size);
        auto comp_size = ECL_ZeroDevourer_Compress(src_data, src_size, tmp.data(), enough_size);

        tmp_output.resize(src_size);
        auto decomp_size = ECL_ZeroDevourer_Decompress(tmp.data(), comp_size, tmp_output.data(), src_size);
        approve(decomp_size == src_size);
        approve(0 == memcmp(src_data, tmp_output.data(), src_size));
    }
}

NTEST(test_NanoLZ_slow_datasets) {
    std::vector<uint8_t> tmp;
    std::vector<uint8_t> tmp_output;
    for(auto& rec : GetDatasetRecords()) {
        auto src_data = (const uint8_t*)rec.ptr;
        auto src_size = rec.length;
        approve(src_data);
        approve(src_size);

        auto enough_size = ECL_NANO_LZ_GET_BOUND(src_size);
        tmp.resize(enough_size);
        for(auto scheme : ECL_NANO_LZ_SCHEMES_ALL) {
            auto comp_size = ECL_NanoLZ_Compress_slow(scheme, src_data, src_size, tmp.data(), enough_size, -1);
            tmp_output.resize(src_size);
            auto decomp_size = ECL_NanoLZ_Decompress(scheme, tmp.data(), comp_size, tmp_output.data(), src_size);
            approve(decomp_size == src_size);
            approve(0 == memcmp(src_data, tmp_output.data(), src_size));
        }
    }
}

NTEST(test_NanoLZ_fast1_datasets) {
    std::vector<uint8_t> tmp;
    std::vector<uint8_t> tmp_output;

    ECL_NanoLZ_FastParams fp;
    ECL_NanoLZ_FastParams_Alloc1(&fp, 10);
    for(auto& rec : GetDatasetRecords()) {
        auto src_data = (const uint8_t*)rec.ptr;
        auto src_size = rec.length;
        approve(src_data);
        approve(src_size);

        auto enough_size = ECL_NANO_LZ_GET_BOUND(src_size);
        tmp.resize(enough_size);
        for(auto scheme : ECL_NANO_LZ_SCHEMES_ALL) {
            auto comp_size = ECL_NanoLZ_Compress_fast1(scheme, src_data, src_size, tmp.data(), enough_size, -1, &fp);
            tmp_output.resize(src_size);
            auto decomp_size = ECL_NanoLZ_Decompress(scheme, tmp.data(), comp_size, tmp_output.data(), src_size);
            approve(decomp_size == src_size);
            approve(0 == memcmp(src_data, tmp_output.data(), src_size));
        }
    }
    ECL_NanoLZ_FastParams_Destroy(&fp);
}

NTEST(test_NanoLZ_fast2_datasets) {
    std::vector<uint8_t> tmp;
    std::vector<uint8_t> tmp_output;

    ECL_NanoLZ_FastParams fp;
    ECL_NanoLZ_FastParams_Alloc2(&fp, 10);
    for(auto& rec : GetDatasetRecords()) {
        auto src_data = (const uint8_t*)rec.ptr;
        auto src_size = rec.length;
        approve(src_data);
        approve(src_size);

        auto enough_size = ECL_NANO_LZ_GET_BOUND(src_size);
        tmp.resize(enough_size);
        for(auto scheme : ECL_NANO_LZ_SCHEMES_ALL) {
            auto comp_size = ECL_NanoLZ_Compress_fast2(scheme, src_data, src_size, tmp.data(), enough_size, -1, &fp);
            tmp_output.resize(src_size);
            auto decomp_size = ECL_NanoLZ_Decompress(scheme, tmp.data(), comp_size, tmp_output.data(), src_size);
            approve(decomp_size == src_size);
            approve(0 == memcmp(src_data, tmp_output.data(), src_size));
        }
    }
    ECL_NanoLZ_FastParams_Destroy(&fp);
}
